// tslint:disable
/**
 * Trading.ServiceManagerUtils.Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from "rxjs";
import type { AjaxResponse } from "rxjs/ajax";
import { BaseAPI, throwIfNullOrUndefined } from "../runtime";
import type { OperationOpts, HttpHeaders, HttpQuery } from "../runtime";
import type { SyncComment } from "../models";

export interface RequestsAddCommentRequest {
  id: string;
  comment: SyncComment;
}

export interface RequestsCheckExistsRequest {
  id: string;
}

export interface RequestsCloseRequest {
  id: string;
}

export interface RequestsCommentsRequest {
  id: string;
}

export interface RequestsIsClosedRequest {
  id: string;
}

export interface RequestsPropertyValueRequest {
  id: string;
  propertyName: string;
}

/**
 * no description
 */
export class RequestsApi extends BaseAPI {
  /**
   */
  requestsAddComment({
    id,
    comment,
  }: RequestsAddCommentRequest): Observable<void>;
  requestsAddComment(
    { id, comment }: RequestsAddCommentRequest,
    opts?: OperationOpts,
  ): Observable<void | AjaxResponse<void>>;
  requestsAddComment(
    { id, comment }: RequestsAddCommentRequest,
    opts?: OperationOpts,
  ): Observable<void | AjaxResponse<void>> {
    throwIfNullOrUndefined(id, "id", "requestsAddComment");
    throwIfNullOrUndefined(comment, "comment", "requestsAddComment");

    const headers: HttpHeaders = {
      "Content-Type": "application/json",
    };

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      id: id,
    };

    return this.request<void>(
      {
        url: "/api/requests/addcomment",
        method: "PUT",
        headers,
        query,
        body: comment,
      },
      opts?.responseOpts,
    );
  }

  /**
   */
  requestsCheckExists({ id }: RequestsCheckExistsRequest): Observable<boolean>;
  requestsCheckExists(
    { id }: RequestsCheckExistsRequest,
    opts?: OperationOpts,
  ): Observable<AjaxResponse<boolean>>;
  requestsCheckExists(
    { id }: RequestsCheckExistsRequest,
    opts?: OperationOpts,
  ): Observable<boolean | AjaxResponse<boolean>> {
    throwIfNullOrUndefined(id, "id", "requestsCheckExists");

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      id: id,
    };

    return this.request<boolean>(
      {
        url: "/api/requests/exists",
        method: "GET",
        query,
      },
      opts?.responseOpts,
    );
  }

  /**
   */
  requestsClose({ id }: RequestsCloseRequest): Observable<void>;
  requestsClose(
    { id }: RequestsCloseRequest,
    opts?: OperationOpts,
  ): Observable<void | AjaxResponse<void>>;
  requestsClose(
    { id }: RequestsCloseRequest,
    opts?: OperationOpts,
  ): Observable<void | AjaxResponse<void>> {
    throwIfNullOrUndefined(id, "id", "requestsClose");

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      id: id,
    };

    return this.request<void>(
      {
        url: "/api/requests/close",
        method: "PUT",
        query,
      },
      opts?.responseOpts,
    );
  }

  /**
   */
  requestsComments({
    id,
  }: RequestsCommentsRequest): Observable<Array<SyncComment>>;
  requestsComments(
    { id }: RequestsCommentsRequest,
    opts?: OperationOpts,
  ): Observable<AjaxResponse<Array<SyncComment>>>;
  requestsComments(
    { id }: RequestsCommentsRequest,
    opts?: OperationOpts,
  ): Observable<Array<SyncComment> | AjaxResponse<Array<SyncComment>>> {
    throwIfNullOrUndefined(id, "id", "requestsComments");

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      id: id,
    };

    return this.request<Array<SyncComment>>(
      {
        url: "/api/requests/comments",
        method: "GET",
        query,
      },
      opts?.responseOpts,
    );
  }

  /**
   */
  requestsIsClosed({ id }: RequestsIsClosedRequest): Observable<boolean>;
  requestsIsClosed(
    { id }: RequestsIsClosedRequest,
    opts?: OperationOpts,
  ): Observable<AjaxResponse<boolean>>;
  requestsIsClosed(
    { id }: RequestsIsClosedRequest,
    opts?: OperationOpts,
  ): Observable<boolean | AjaxResponse<boolean>> {
    throwIfNullOrUndefined(id, "id", "requestsIsClosed");

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      id: id,
    };

    return this.request<boolean>(
      {
        url: "/api/requests/isclosed",
        method: "GET",
        query,
      },
      opts?.responseOpts,
    );
  }

  /**
   */
  requestsPropertyValue({
    id,
    propertyName,
  }: RequestsPropertyValueRequest): Observable<string>;
  requestsPropertyValue(
    { id, propertyName }: RequestsPropertyValueRequest,
    opts?: OperationOpts,
  ): Observable<AjaxResponse<string>>;
  requestsPropertyValue(
    { id, propertyName }: RequestsPropertyValueRequest,
    opts?: OperationOpts,
  ): Observable<string | AjaxResponse<string>> {
    throwIfNullOrUndefined(id, "id", "requestsPropertyValue");
    throwIfNullOrUndefined(
      propertyName,
      "propertyName",
      "requestsPropertyValue",
    );

    const query: HttpQuery = {
      // required parameters are used directly since they are already checked by throwIfNullOrUndefined
      id: id,
      propertyName: propertyName,
    };

    return this.request<string>(
      {
        url: "/api/requests/property",
        method: "GET",
        query,
      },
      opts?.responseOpts,
    );
  }
}
